#include <stdio.h>

int main() {
    int N;
    int cnt[10] = {0};
    scanf("%d", &N);

    int factor = 1;
    while (factor <= N) {
        int lower = N - (N / factor) * factor;
        int current = (N / factor) % 10;
        int higher = N / (factor * 10);

        for (int i = 0; i < 10; i++) {
            cnt[i] += higher * factor;
        }
        cnt[0] -= factor;

        for (int i = 0; i < current; i++) {
            cnt[i] += factor;
        }
        
        cnt[current] += lower + 1;

        factor *= 10;
    }

    for (int i = 0; i < 10; i++) {
        printf("%d ", cnt[i]);
    }
    return 0;
}

//Description
/*
지민이는 전체 페이지의 수가 N인 책이 하나 있다. 첫 페이지는 1 페이지이고, 마지막 페이지는 N 페이지이다.
각 숫자가 전체 페이지 번호에서 모두 몇 번 나오는지 구해보자.
*/
//Input
/*
첫째 줄에 N이 주어진다. N은 1,000,000,000보다 작거나 같은 자연수이다.
*/
//Output
/*
첫째 줄에 0이 총 몇 번 나오는지, 1이 총 몇 번 나오는지, ..., 9가 총 몇 번 나오는지를 공백으로 구분해 출력한다.
*/

//Solution
/*
처음에는 단순히 for문을 통해 1부터 입력받은 N까지 순회하며 해당 수의 각 자리 숫자를 알아내어 배열의 각 항에 1을 추가하는 코드를 짬
#include <stdio.h>

int main() {
    int N;
    int cnt[10] = {0};
    scanf("%d", &N);

    for (int i=0; i<=N; i++) {
        int temp = i;
        while (temp) {
            int digit;
            digit = temp % 10;
            temp /= 10;
            cnt[digit] += 1;
        }
    }
    for (int i = 0; i<10; i++) {
        printf("%d ", cnt[i]);
    }

    return 0;
}
이 코드이다.
그러나 이 코드는 N이 커졌을 때 실행 시간이 오래 걸려 시간 초과가 뜸

실행 시간을 줄일 수 있는 방법을 생각하다 N의 각 자리 수에 따라 숫자가 얼마나 나오는지 분석하여 봄
자릿수를 1의 자리, 10의 자리, 100의 자리, ...를 각각 반복문을 통해 확인하고
현재 자리 숫자를 current, 그보다 더 높은 자리 모든 숫자를 higher, 낮은 자리 숫자를 lower에 저장함
다음과 같은 알고리즘을 통해 코드를 짰다
N = 234일 때를 예시로 하자
여기서 higher = a, current = b, lower = c라고 놓았고, n은 0~9의 숫자가 모두 들어갈 수 있음을 의미함
---------------------------------------------------
	|	a		b		c	
---------------------------------------------------
1의 자리(factor = 1)
	|	23		4		0
	|	230		4		0
	|
	|	OOx		23O		23b
	|
	|	00n		230		234
	|	01n		231		
	|	02n		232		
	|	.		233		
	|	.				
	|	.				
	|	06n					
	|	09n				
	|	10n				
	|	11n
	|	.
	|	.
	|	.
	|	21n
	|	22n		
	|	여기서 , 000인 경우에 0의 개수가 1 추가되므로 cnt[0]에서 1을 빼줌
---------------------------------------------------
10의 자리(factor = 10)
	|	2		3		4
	|	200		30		4
	|
	|	OxO		2Ox		2bO
	|
	|	0n0		20n		220
	|	0n1		21n		221
	|	0n2		22n		222
	|	.				223
	|	.
	|	.
	|	0n9
	|	1n0
	|	1n1
	|	1n2
	|	.
	|	.
	|	.
	|	1n8
	|	1n9
	|	여기서, 00n인 경우에 0의 개수가 추가되므로 cnt[0]에서 10을 빼줌
---------------------------------------------------
100의 자리(factor = 100)
	|	0		2		34
	|	0		200		34
	|			
	|			Oxx		bOO
	|			
	|			0nn		200
	|			1nn		201
	|					202
	|					.
	|					.
	|					.
	|					232
	|					233
	|	여기서, 0nn인 경우에 0의 개수가 추가되므로 cnt[0]에서 100을 빼줌
---------------------------------------------------

이 예시를 기반으로,
더 높은 자리수에 따라 각 숫자가 등장하는 횟수를 cnt에 추가하고,
그 다음에 현재 자리수가 포함되는 숫자의 빈도수를 cnt에 추가하고,
마지막으로 포함되면 안되는 0이 추가된 횟수가 factor만큼이므로 그 수를 cnt[0]에서 빼주는 코드를 만듦
*/